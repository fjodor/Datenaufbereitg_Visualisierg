---
title: "Datenaufbereitung und Visualisierung mit R"
author: "WR"
date: "Bearbeitungsstand: `r Sys.time()`"
output: 
  html_document:
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
    code_folding: show
---

```{r setup, include = FALSE}

knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
# load("Alben.Rda")
```


# Datenimport - Herausforderungen mit Datentypen

* Zum Einstieg; nicht zu lang
* Beispiele für Datumsformate, strings_as_factors
* Excel: unheadr, https://luisdva.github.io/rstats/unheadr-cat/
* Excel: tidyxl, https://cran.r-project.org/web/packages/tidyxl/vignettes/tidyxl.html


## Excel-Daten importieren

### Zum Aufwärmen

Einfaches Beispiel ... readxl


### Herausforderung: Informationen in Zellenformatierungen! Dogs 100

![Dogs: 100 yards Sprints; Rasse aus Formatierung (Hervorhebung) erkennbar](dogs_100yards_screenshot.png)

```{r unheadr_dogs100_data}

# Quelle: https://luisdva.github.io/rstats/unheadr-cat/
# Luis Verde Arregoitia

library(here)

CATspsheet <- tempfile(fileext = ".xlsx")
curl::curl_download("https://github.com/luisDVA/codeluis/blob/master/fastCAT2015.xlsx?raw=true", CATspsheet)

# Importieren mit readxl
readxl::read_excel(CATspsheet)

# Excel-Dokument im Arbeitsverzeichnis ablegen

datei <- paste0(here::here(), "/dogs_100yards.xlsx")
curl::curl_download("https://github.com/luisDVA/codeluis/blob/master/fastCAT2015.xlsx?raw=true", datei)

```

Das **CAT** im Dateipfad steht übrigens für **Coursing Ability Test**.

So weit, so schlecht ... Wie können wir die Daten mit wenig Aufwand aufbereiten?
Wie müsste ein "tidy data"-Format aussehen?

* Jede Zeile ein Fall (hier: ein Hund)
* Jede Spalte eine Variable

--> Rasse muss zu einer separaten Variable werden.  
Wie machen wir das?

Schlechte Lösung: Bearbeitung in Excel. Manuell, nicht automatisiert reproduzierbar! (Es sei denn per VBA)  
Besser: Volle Automatisierung in R. Das bedeutet: Wir benötigen Informationen über die Zellenformatierungen in R.

### unheadr: Excel-Formatierungen in R sichtbar machen

```{r unheadr_dogs100_annotate_mf}

library(unheadr)

Hunderassen <- annotate_mf(CATspsheet, orig = Dog, new = dog_annotated)
Hunderassen

```

Funktion: annotate_mf; das "mf" steht für "meaningful formatting", also inhaltlich relevante Formatierungen
Siehe *?annotate_mf*:

* Vier Formatierungsarten werden automatisch behandelt:  
**fett**, *kursiv*, $\underline{unterstrichen}$, sowie Zellformatierungen.

* annotate_mf möchte einen Pfad zum Exceldokument haben, d. h. die Daten liegen nicht im R-Arbeitsspeicher!

Jetzt haben wir die Formatierungs-Informationen in R. Nächster Schritt: weiterverarbeitung mit regex!


### Exkurs: Kurze Einführung in regex - wird später vertieft

Ziel: Praxisorientiert bleiben.

Def.: Reguläre Ausdrücke (**regular expressions**, kurz **regex**) sind ein präzises, flexibles Werkzeug, um Muster in Texten zu beschreiben.

Weiterführende Infos:

* Vignette im *stringr*-Paket: `vignette("regular-expressions", package = "stringr")`
* Kapitel in *R for Data Science (R4DS)*: https://r4ds.had.co.nz/strings.html
* *RegexOne*: Reguläre Ausdrücke lernen mit einfachen, interaktiven Übungen (engl.): https://regexone.com/

Hier benötigen wir erst mal nur wenige Infos - später vertiefen wir das Thema:

Es gibt Sonderzeichen, die bestimmte Eigenschaften beschreiben:

* Anfang des Textes: ^
* Ende des Textes: $

Somit haben einige Zeichen eine besondere Bedeutung in regulären Ausdrücken. Wir müssen also unterscheiden, ob wir ein Zeichen "wörtlich" meinen (es kommt in unserem Text vor und wir suchen danach), oder ob wir seine spezielle Bedeutung als regulärer Ausdruck meinen.

Beispiele für solche Zeichen, neben den oben gezeigten für Anfang und Ende, sind Klammern - sowohl runde () als auch eckige [].

Wollen wir "wörtlich" nach Klammern suchen, müssen wir sie "maskieren" (engl. *escape*). Das Maskierungszeichen ist der Backslash \\.

In Strings (Text-Vektoren in R) wird der Backslash bereits als *escape-Symbol* verwendet. Beispiele:

* Zeilenumbruch \\n
* Tabulator \\t

Beispiel:

```{r Exkurs_Escape}

cat("Tabulator\tWeiterer Text\nNach Zeilenumbruch")

```

Daher benötigen wir für reguläre Ausdrücke in Strings **zwei Backslashes \\\\**.


### unheadr: Excel-Formatierungen für die Datenaufbereitung nutzen

Oben gesehen: Formatierungs-Informationen stehen zu Beginn des Textes in Klammern.  
--> Wir suchen nach einer Klammer am Anfang, um die Hunderasse zu ermitteln

```{r unheadr_dogs100_regex}

Hunderassen2 <- Hunderassen %>% 
  untangle2("^\\(", orig = dog_annotated, new = breed)

Hunderassen2

```

Der entscheidende Trick hier ist der reguläre Ausdruck **\^\\(**. **^** sucht am Anfang des Strings, und zwar nach einer geöffneten runden Klammer, die mit zwei Backslashes *maskiert* werden muss, da sie sonst eine andere Bedeutung innerhalb der regulären Ausdrücke hätte (Beispiele dafür sehen wir später: Es geht um Zeichengruppen): **\\\\(**.

Nächster Schritt: Die Zellformatierung aus der Spalte *breed* (Hunderasse) entfernen - wieder mit regex.

Hier: **(highlighted-FFADC5E7) **, mit Leerzeichen nach der Klammer. Danach beginnt die Hunderasse.

Dazu benötigen wir ein paar weitere Tricks:

* Ein Punkt **.** steht wie ein *Joker* für ein beliebiges Zeichen.
* Ein Plus **+** bedeutet: Eine oder mehr Wiederholungen.
* **.+** bedeutet also ein oder mehr beliebige Zeichen.
* Die geschlossene Klammer beschreiben wir analog zu oben mit **\\\\)**.
* Schließlich gibt es noch ein spezielles Kürzel für Leerzeichen: s (*space*). Wir maskieren es: **\\s**.

Wir verwenden *str_remove* aus dem *stringr*-Paket, um die Zeichenfolge, die wir mit dem regulären Ausdruck beschreiben, zu entfernen.

```{r unheadr_dogs100_regex2}

Hunderassen2 <- Hunderassen2 %>% 
  mutate(breed = stringr::str_remove(breed, "^\\(.+\\)\\s")) %>% 
  select(-dog_annotated)

Hunderassen2

```

Unser regulärer Ausdruck, um die Zellformatierung aus der Hunderasse zu entfernen, lautet somit: **^\\\\(.+\\\\)\\\\s**.

Voilà!


## unpivotr / tidyxl: "Schwierige" Daten v. a. aus Excel laden

Ausführliches Buch: "Spreadsheet Munging Strategies" von Duncan Garmonsway  
Autor von tidyxl, unpivotr, smungs (Beispiel-Datensätze für das Buch, liefert Pfade zu den Exceldaten)

https://nacnudus.github.io/spreadsheet-munging-strategies/index.html


### tidyxl: Excel-Informationen nach R "hinüberretten"

Grundidee: Software, die Daten aus Excel in andere Programme importiert, trifft oft einschränkende Annahmen bzw. "zwingt" die Daten in ein bestimmtes Format, in der Regel Datensatz (jede Zeile ein Fall, jede Spalte eine Variable, eine Zeile für Spaltenüberschriften). Dabei gehen oft Informationen verloren.

**tidyxl** zielt darauf ab, so viel Informationen wie möglich aus Excel nach R zu übertragen.

Ausblick, siehe https://cran.r-project.org/web/packages/tidyxl/vignettes/tidyxl.html

* Paket **jailbreaker**, um nicht-datensatzförmige Daten *automatisiert* ins Datensatzformat zu übertragen
* Ähnliches Ziel, abweichende Philosophie: Paket **unpivotr**; enger auf tidyxl bezogen
* **rsheets**-Projekt: mehrere Pakete, die Arbeitsblatt-Informationen importieren aus Excel und Google Sheets
* **cellranger**, um Excel-Zellbezüge zu verarbeiten

### unpivotr: Nicht-datensatzförmige ("nicht-rechteckige") Daten v. a. aus Excel laden

Nicht-datensatzförmige ("nicht-rechteckige") Daten v. a. aus Excel laden


### Vorbildliche Daten - readxl nachbauen

```{r nacnudus1_clean_data}

library(unpivotr)

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")

library(openxlsx)
openXL(path)

library(readxl)
read_excel(path, sheet = "clean")

library(tidyxl)

xlsx_cells(path, sheet = "clean") %>%
  # behead("N", header) %>%
  # direction "N" is discouraged (see ?direction). Better use "up".
  behead("up", header) %>% 
  # unpivotr::behead() like tidyr::gather, but for more than one row of headers
  select(row, data_type, header, character, numeric) %>%
  spatter(header) %>%
  # spatter is like tidyr::spread, but for different data types
  # designed specifically to work with tidyr::xlsx_cells() or unpivotr::as_cells()
  # recommended to drop col column first, keep row column until spatter step
  select(-row)


```


### Fast ordentliche Daten

#### Transponiert (Variablennamen in erster Spalte statt Zeile)

Das readxl-Beispiel ist kompliziert (erklärungsbedürftig).

Für tidyxl und unpivotr spielt es keine Rolle, in welcher Richtung die Daten angeordnet sind. Man muss lediglich das *direction*-Argument angeben: "left" statt "up".

```{r almost_tidy_transpose}

# read_excel(path, sheet = "transposed", col_names = FALSE) %>%
#   t() %>%
#   `colnames<-`(.[1, ]) %>%
#   .[-1, ] %>%
#   as_tibble()

xlsx_cells(path, sheet = "transposed") %>%
  behead("left", header) %>%
  select(col, data_type, header, character, numeric) %>%
  spatter(header) %>%
  select(Name, Age)

```


#### Andere Infos auf gleichem Arbeitsblatt

Es wird komplizierter, wenn die Daten nicht in Zelle A1 beginnen.

Wenn man das genaue Layout kennt:
* leere Zeilen oberhalb: readxl::read_excel(skip = ...)
* leere Spalten: readxl::read_excel(col_types = ...)
* leere Spalten unterhalb: readxl::read_excel(n_max = ...)

```{r almost_tidy_other_stuff_readxl1}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
readxl::read_excel(path,
                   sheet = "notes",
                   skip = 2,
                   n_max = 33,
                   col_types = c("guess", "guess", "skip")) %>%
  drop_na()



```

Wenn Layout während Skripterstellung unbekannt: tidyxl::xlsx_cells(), um die Datengrenzen zu bestimmen, dann Argumente zu readxl::read_excel() entsprechend füllen.

```{r almost_tidy_other_stuff_readxl2}

cells <- xlsx_cells(path, sheet = "notes")
rectify(cells)

top_left <-
  dplyr::filter(cells, character == "Name") %>%
  select(row, col)
top_left

bottom_right <-
  dplyr::filter(cells, data_type == "numeric") %>%
  summarise(row = max(row), col = max(col))
bottom_right

skip <- top_left$row - 1L
n_rows <- bottom_right$row - skip

read_excel(path, sheet = "notes", skip = skip, n_max = n_rows)

```


```{r almost_tidy_other_stuff_tidyxl_unpivotr}

cells %>%
  dplyr::filter(between(row, top_left$row, bottom_right$row),
         between(col, top_left$col, bottom_right$col)) %>%
  select(row, col, data_type, character, numeric) %>%
  behead("up", header) %>%
  select(-col) %>%
  spatter(header) %>%
  select(-row)

```

### Inhaltlich bedeutsame Zeilen-Formatierungen

Formatierungen müssen interpretiert werden.

```{r Formatierungen_Zeile1}

# Blatt ohne Format-Infos lesen
path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
x <- read_excel(path, sheet = "highlights")

# Formatierungen aus einer Spalte lesen
# Rückgabeformat von xlsx_formats(): genistete Liste! Extrem viel Info

str(xlsx_formats(path), max.level = 2)

fill_colours <- tidyxl::xlsx_formats(path)$local$fill$patternFill$fgColor$rgb

# Alle Zellen lesen, Kopfzeile ausfiltern, Spalte fill_colour erzeugen, format_id nachschlagen

fills <-
  xlsx_cells(path, sheet = "highlights") %>%
  dplyr::filter(row >= 2, col == 1) %>% # Omit the header row
  mutate(fill_colour = fill_colours[local_format_id]) %>%
  select(fill_colour)

# Diese Spalte an die Daten anhängen

bind_cols(x, fills) %>%
  select(Age, Height, fill_colour)


```

Der Index local_format_id ist eine Variable aus xlsx_cells().

Ergebnis: RGB-Wert; erste beiden Buchstaben: Transparenz.  
Beispiel: FFFFFF00 ist FF (opaque = undurchsichtig) mit FFFF00 (gelb).

Alternative nur mit tidyxl und unpivotr:

```{r Formatierungen_Zeile2}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
x <- read_excel(path, sheet = "highlights")

fill_colours <- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb

xlsx_cells(path, sheet = "highlights") %>%
  mutate(fill_colour = fill_colours[local_format_id]) %>%
  select(row, col, data_type, character, numeric, fill_colour) %>%
  behead("up", header) %>%
  select(-col, -character) %>%
  spatter(header) %>%
  select(-row)

```


### Inhaltlich bedeutsame Zellen-Formatierungen

Info bezieht sich nur auf Zelle, nicht auf ganze Zeile

Lasse umständliche Variante mit readxl und dplyr weg ...

```{r Formatierungen_Zelle1}

fill_colours <- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb

cells <-
  xlsx_cells(path, sheet = "annotations") %>%
  mutate(fill_colour = fill_colours[local_format_id]) %>%
  select(row, col, data_type, character, numeric, fill_colour)
cells

values <-
  cells %>%
  select(-fill_colour) %>%
  behead("up", header) %>%
  select(-col) %>%
  spatter(header)
values

fills <-
  cells %>%
  behead("up", header) %>%
  mutate(header = paste0(header, "_fill")) %>%
  select(row, header, fill_colour) %>%
  spread(header, fill_colour)
fills

left_join(values, fills, by = "row") %>%
  select(-row)

```


"Extra tidy": Jede Zeile ist eine Beobachtung **einer Variable**. (Funktioniert am besten, wenn die Variablen den gleichen Datentyp aufweisen, sonst Umwandlung!)

Sinn: Werte individueller Variablen statt individueller Beobachtungen können damit formiert werden.

Lasse wieder die umständlichere Variante mit readxl und dplyr weg.

```{r Formatierungen_Zelle_extra_tidy}

fill_colours <- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb

xlsx_cells(path, sheet = "annotations") %>%
  mutate(fill_colour = fill_colours[local_format_id]) %>%
  select(row, col, data_type, character, numeric, fill_colour) %>%
  behead("left", Name) %>%
  behead("up", variable) %>%
  select(-data_type, -character, value = numeric)

```


### Überlagerte bedeutsame Formatierungen

Mehrfache Formatierungen, Beispiel:

* gelb hervorgehoben: unsichere Daten
* roter Text: Produkt nicht mehr verfügbar
* beides: beides

Nur die Lösung mit tidyxl und unpivotr

```{r Formatierungen_überlagert}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")

fill_colours <- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb
font_colours <- xlsx_formats(path)$local$font$color$rgb

cells <-
  xlsx_cells(path, sheet = "combined-highlights") %>%
  mutate(fill_colour = fill_colours[local_format_id],
         font_colour = font_colours[local_format_id]) %>%
  select(row, col, data_type, character, numeric, fill_colour, font_colour) %>%
  behead("up", header) %>%
  behead("left", Name) %>%
  select(-col, -character)

values <-
  cells %>%
  select(-fill_colour, -font_colour) %>%
  spread(header, numeric)

formats <- distinct(cells, row, fill_colour, font_colour)

left_join(values, formats, by = "row") %>%
  select(-row)

```


### Hierarchien in der Formatierung

Beispiel:

* Keine Formatierung: gut
* kursiv: zufriedenstellend
* fett: schlecht
* fett und kursiv: ungenügend

Vorgehen: Formatierungen in unterschiedliche Spalten übernehmen, dann zu Gesamtspalte kombinieren (paste, case_when)

Mit tidyxl und unpivotr

```{r Formatierungen_Hierarchie}

bold <- xlsx_formats(path)$local$font$bold
italic <- xlsx_formats(path)$local$font$italic

xlsx_cells(path, sheet = "highlight-hierarchy") %>%
  mutate(bold = bold[local_format_id],
         italic = italic[local_format_id]) %>%
  mutate(grade = case_when(bold & italic ~ "fail",
                           bold ~ "poor",
                           italic ~ "satisfactory",
                           TRUE ~ "good")) %>%
  select(row, col, data_type, character, numeric, bold, italic, grade) %>%
  behead("up", header) %>%
  select(-col) %>%
  spatter(header)

```

### Spezielle Kennungen (sentinel values) in Nicht-Text-Spalten

* In readr kann man Zeichen als Fehlwerte definieren
* Was dort nicht geht: Unterschiedliche _Arten_ von speziellen Werten definieren

Beispiel, Statistics New Zealand:

* ... = "Not applicable"
* ..C = "Confidentialised"

Die meisten Tools / Pakete werden beides als NA importieren oder die gesamte Spalte als Text behandeln.

Beispiele für beides mit read_csv ...

Besser: Kennungen in separate Spalte importieren, oder sogar TRUE / FALSE für jede Kennung ("Wächter") separat.

Nur Lösung mit tidyxl und unpivotr: Funktion *unpivotr::isolate_sentinels()*

```{r Sentinels}

xlsx_cells(path, sheet = "sentinels") %>%
  select(row, col, data_type, character, numeric) %>%
  isolate_sentinels(character, c("NA", "…", "..C")) %>%
  behead("left", Name) %>%
  behead("up", variable) %>%
  select(Name, variable, character, numeric, sentinel)


```

## Pivot-Tabellen

Hier sind tidyxl und unpivotr zu Hause ...

* Def. Pivot-Tabellen: Mehr als eine Spalten- und / oder Zeilen-Überschrift
* Benötigen weniger Platz auf dem Blatt und sind besser lesbar als tidy data
* Für Software schwieriger zu verarbeiten
* Uneindeutigkeit (*ambiguities*): oft unklar, ob eine Zelle zu einer Zeilen- / Spaltenüberschrift gehört oder Daten enthält

==> Vorgehen in Einzelschritte aufteilen, nicht alles mit einer Mega-Funktion erschlagen

1. Ermitteln, welche Zellen Überschriften / Köpfe (*headers*) sind und welche Daten enthalten
2. Feststellen, wie sich die Daten auf die Tabellenköpfe beziehen

Zu 1: Wird sehr vereinfacht durch tidyxl, mit mit unpivotr::as_cells()    
--> Zelleneigenschaften; eine Zeile im Datensatz beschreibt eine Zelle des Excelblattes

* Zeilen- und Spaltenposition --> danach kann man dann filtern

Beispiel: Zwei Zeilen und zwei Spalten sind Köpfe

Hier: readxl

```{r pivot_annotations1}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
original <- read_excel(path, sheet = "pivot-annotations", col_names = FALSE)

print(original, n = Inf)

```


Zum Vergleich: *tidyxl::xlsx_cells*. Nur ausgewählte Infos zur besseren Lesbarkeit

```{r pivot_annotations2}

cells <- xlsx_cells(path, sheets = "pivot-annotations")
select(cells, row, col, data_type, character, numeric) %>%
  print(cells, n = 20)

```

Zum Vergleich: *unpivotr::as_cells()*

```{r pivot_annotations3}

original <- read_excel(path, sheet = "pivot-annotations", col_names = FALSE)

as_cells(original) %>%
  arrange(row, col) %>%
  print(n = 20)

```

Unterschiede:

* read_excel() hat fehlende Zellen ergänzt, as_cells() behält diese
* read_excel() hat alle Datentypen in character umgewandelt, während xlsx_cells() die ursprünglichen Datentypen behält

Mit tidyxl kann man einfacher weiterarbeiten, da wir Positionen und Werte zu jeder Zelle kennen.

```{r pivot_annotations4}

dplyr::filter(cells, row == 2, !is_blank) %>%
  select(row, col, character, numeric)

dplyr::filter(cells, data_type == "numeric") %>%
  select(row, col, numeric)

```

Im Folgenden: Wie können wir Beziehungen zwischen Tabellenköpfen und Datenzellen beschreiben? **unpivotr**


### Einfache Pivot-Tabellen

#### Zwei Zeilen mit Spaltenköpfen, linksbündig

*unpivotr::behead()* nimmt eine Ebene Tabellenköpfe und ordnet sie den Daten zu. Ähnlich tidyr::gather(), aber:

* funktioniert mit mehr als einer Kopfzeile bzw. Kopf-Spalte
* funktioniert nur mit Objekten, die aus *unpivotr::as_cells()* oder *tidyxl::xlsx_cells()* kommen

```{r unpivotr_311a}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "pivot-annotations") %>%
  dplyr::filter(col >= 4, !is_blank) %>% # Ignore the row headers in this example
  select(row, col, data_type, character, numeric)
all_cells

```


* Erste Zeile ist äußerer Kopf; "Female" und "Male" stehen oberhalb und links von den Daten-Zellen: "up-left"
* Wir benennen die Köpfe: sex
* Welche Spalte enthält die zugehörigen Werte: meist die *character*-Spalte

```{r unpivotr_311b}

all_cells %>%
  behead("up-left", sex)

```

* Hälfte geschafft ... "Matilda" ist ein weiterer Tabellenkopf, kein Inhalt
* Richtung diesmal "up"; Variablenname *name*

```{r unpivotr_311c}

all_cells %>%
  behead("up-left", sex) %>%
  behead("up", `name`)

```

Letzter Schritt: Bereinigung.

```{r unpivotr_311d}

all_cells %>%
  behead("up-left", sex) %>%
  behead("up", `name`) %>%
  select(score = numeric, sex, `name`)

```


#### Zwei Zeilen UND SPALTEN mit Tabellenköpfen, linksbündig und oben

Keine neuen Techniken, nur mehr Richtungen: "left", "left-up"

```{r unpivotr_312a}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "pivot-annotations") %>%
  dplyr::filter(!is_blank) %>%
  select(row, col, data_type, character, numeric) %>%
  print()

```

```{r unpivotr_312b}

all_cells %>%
  behead("up-left", sex) %>%   # As before
  behead("up", `name`) %>%     # As before
  behead("left-up", field) %>% # Left-and-above
  behead("left", subject) %>%  # Directly left
  rename(score = numeric) %>%
  select(-row, -col, -character)

```


#### Mehrere Zeilen und Spalten mit Köpfen sowie bedeutsame Formatierungen

```{r unpivotr_313}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "pivot-annotations") %>%
  dplyr::filter(!is_blank) %>%
  select(row, col, data_type, character, numeric) %>%
  print()

unpivoted <-
  all_cells %>%
  behead("up-left", sex) %>%   # As before
  behead("up", `name`) %>%     # As before
  behead("left-up", field) %>% # Left-and-above
  behead("left", subject) %>%  # Directly left
  rename(score = numeric) %>%
  select(-character)                # Retain the row and col for now
unpivoted

# `formats` is a pallette of fill colours that can be indexed by the
# `local_format_id` of a given cell to get the fill colour of that cell
fill_colours <- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb
fill_colours

# Import all the cells, filter out the header row, filter for the first column,
# and create a new column `approximate` based on the fill colours, by looking up
# the local_format_id of each cell in the `formats` pallette.
annotations <-
  xlsx_cells(path, sheets = "pivot-annotations") %>%
  dplyr::filter(row >= 4, col >= 4) %>% # Omit the headers
  mutate(fill_colour = fill_colours[local_format_id]) %>%
  select(row, col, fill_colour)
annotations

left_join(unpivoted, annotations, by = c("row", "col")) %>%
  select(-row, -col)

```


#### Köpfe und Notizen in Zeilen / Spalten vermischt

```{r unpivotr_314a}

# Error: object formats fehlt

# cells <- xlsx_cells(path, sheets = "pivot-annotations")
# 
# cells %>%
#   behead_if(formats$local$font$bold[local_format_id], # true for bold cells
#             str_detect(character, "^Country: "),      # true for "Country: ..."
#             direction = "left-up",                    # argument must be named
#             name = "country_name") %>%
#   dplyr::filter(col != 1L)                            # discard remaining cells

```

```{r unpivotr_314b}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
formats <- xlsx_formats(path)

italic <- formats$local$font$italic

# For 'red' we can either look for the RGB code for red "FFFF0000"
red <- "FFFF0000"

# Or we can find out what that code is by starting from a cell that we know is
# red.
red_cell_format_id <-
  xlsx_cells(path, sheets = "pivot-notes") %>%
  dplyr::filter(row == 5, col == 2) %>%
  pull(local_format_id)
red_cell_format_id

red <- formats$local$font$color$rgb[red_cell_format_id]
red

cells <-
  xlsx_cells(path, sheets = "pivot-notes") %>%
  dplyr::filter(!is_blank) %>%
  select(row, col, data_type, character, numeric, local_format_id) %>%
  print()

cells %>%
  behead_if(!italic[local_format_id],                             # not italic
            direction = "up-left",
            name = "sex") %>%
  dplyr::filter(row != min(row)) %>% # discard non-header cells
  behead("up", "name") %>%
  behead_if(formats$local$font$color$rgb[local_format_id] != red, # not red
            direction = "left-up",
            name = "field") %>%
  dplyr::filter(col != min(col)) %>% # discard non-headere cells
  behead("left", "subject") %>%
  select(sex, name, field, subject, score = numeric)


```


#### Unterschiedliche Kopf-Ebenen in gleicher Zeile / Spalte: Formatierungen

* Einrückung (*indentation*) zählt auch als Formatierung

```{r unpivotr_315}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
formats <- xlsx_formats(path)

formats$local$alignment$indent

cells <-
  xlsx_cells(path, sheets = "pivot-hierarchy") %>%
  dplyr::filter(!is_blank) %>%
  select(row, col, data_type, character, numeric, local_format_id) %>%
  print()

cells %>%
  behead_if(formats$local$alignment$indent[local_format_id] == 0,
            direction = "left-up",
            name = "field") %>%
  behead("left", "subject") %>%
  behead("up", "name") %>%
  select(field, subject, name, score = numeric)

```


### Komplexe Pivot-Tabellen

*behead()* trifft Annahmen und kann keine Formatierungen lesen.   
Mächtigeres Werkzeug: *enhead()*: fügt zwei separate Datensätze zusammen - Daten-Zellen und Kopf-Zellen

Schritte:
1. Herausfinden, welche Zellen Köpfe und welche Daten enthalten
2. Beschreiben, wie sich die Daten auf die Köpfe beziehen.

#### Zwei Kopfzeilen, linksbündig (wie im vorigen Kapitel!)

Schritt 1 benötigt lediglich Filterung:

```{r unpivotr_321a}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "pivot-annotations") %>%
  dplyr::filter(col >= 4, !is_blank) %>% # Ignore the row headers in this example
  select(row, col, data_type, character, numeric) %>%
  print()

```

Wir können die Zellen in ihrer ursprünglichen Position auf dem Excelblatt anzeigen:

```{r unpivotr_321b}

rectify(all_cells)

```

```{r unpivotr_321c}

first_header_row <-
  dplyr::filter(all_cells, row == 2) %>%
  select(row, col, sex = character)
  # the title of this header is 'sex'
  # the cells are text cells (`"Female"` and `"Male"`) so take the value in the
  # '`character` column.
first_header_row

second_header_row <-
  dplyr::filter(all_cells, row == 3) %>%
  select(row, col, name = character)
  # The title of this header is 'name'.
  # The cells are text cells, so take the value in the '`character` column.
second_header_row

```

```{r unpivotr_321d}

data_cells <-
  dplyr::filter(all_cells, data_type == "numeric") %>%
  select(row, col, score = numeric)
  # The data is exam scores in certain subjects, so give the data that title.
  # The data is numeric, so select only that 'value'.  If some of the data was
  # also text or true/false, then you would select the `character` and `logical`
  # columns as well as `numeric`

```

Zweiter Schritt: Beschreiben, wie sich die Daten-Zellen auf die Köpfe beziehen.

```{r unpivotr_321e}

enhead(data_cells, second_header_row, "up")
enhead(data_cells, first_header_row, "up-left")

```

Finalen, vollständigen "tidy" Datensatz erzeugen

```{r unpivotr_321f}

data_cells %>%
  enhead(first_header_row, "up-left") %>%
  enhead(second_header_row, "up") %>%
  select(-row, -col)

```


#### Zwei Spalten mit Tabellenköpfen, oben ausgerichtet

Fast wie eben, nur mit anderen Richtungen: "left" und "left-up". ("up-left" = "left up" in enhead(), aber nicht in behead()!)

```{r unpivotr_322}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "pivot-annotations") %>%
  dplyr::filter(row >= 3, !is_blank) %>% # Ignore the column headers in this example
  select(row, col, data_type, character, numeric) %>%
  print()

rectify(all_cells)

first_header_col <-
  dplyr::filter(all_cells, col == 2) %>%
  select(row, col, field = character)
  # the title of this header is 'field', meaning 'group of subjects'.
  # The cells are text cells (`"Humanities"`, `"Performance"`) so take the value
  # in the '`character` column.
first_header_col

second_header_col <-
  dplyr::filter(all_cells, col == 3) %>%
  select(row, col, subject = character)
  # The title of this header is 'subject'
  # The cells are text cells (`"history"`, etc.) so take the value in the
  # '`character` column.
second_header_col

data_cells <-
  dplyr::filter(all_cells, data_type == "numeric") %>%
  select(row, col, score = numeric)
  # The data is examp scores in certain subjects, so give the data that title.
  # The data is numeric, so select only that 'value'.  If some of the data was
  # also text or true/false, then you would select the `character` and `logical`
  # columns as well as `numeric`

data_cells %>%
  enhead(first_header_col, "left-up") %>%
  enhead(second_header_col, "left") %>%
  select(-row, -col)

```


#### Zwei Zeilen UND SPALTEN mit Tabellenköpfen, linksbündig und oben {#Zeilen_Spalten}

```{r unpivotr_323}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "pivot-annotations") %>%
  dplyr::filter(!is_blank) %>%
  select(row, col, data_type, character, numeric) %>%
  print()

rectify(all_cells)

first_header_row <-
  dplyr::filter(all_cells, row == 2) %>%
  select(row, col, sex = character)
  # the title of this header is 'sex'
  # the cells are text cells (`"Female"` and `"Male"`) so take the value in the
  # '`character` column.
first_header_row

second_header_row <-
  dplyr::filter(all_cells, row == 3) %>%
  select(row, col, name = character)
  # The title of this header is 'name'.
  # The cells are text cells, so take the value in the '`character` column.
second_header_row

first_header_col <-
  dplyr::filter(all_cells, col == 2) %>%
  select(row, col, field = character)
  # the title of this header is 'field', meaning 'group of subjects'.
  # The cells are text cells (`"Humanities"`, `"Performance"`) so take the value
  # in the '`character` column.
first_header_col

second_header_col <-
  dplyr::filter(all_cells, col == 3) %>%
  select(row, col, subject = character)
  # The title of this header is 'subject'
  # The cells are text cells (`"history"`, etc.) so take the value in the
  # '`character` column.
second_header_col

data_cells <-
  dplyr::filter(all_cells, data_type == "numeric") %>%
  select(row, col, score = numeric)
  # The data is examp scores in certain subjects, so give the data that title.
  # The data is numeric, so select only that 'value'.  If some of the data was
  # also text or true/false, then you would select the `character` and `logical`
  # columns as well as `numeric`

data_cells %>%
  enhead(first_header_row, "up-left") %>%
  enhead(second_header_row, "up") %>%
  enhead(first_header_col, "left-up") %>%
  enhead(second_header_col, "left") %>%
  select(-row, -col)

```


#### Zentrierte Tabellenköpfe

Trick: *justify()*, um die Tabellenköpfe links und oben auszurichten. Dann weiter wie oben.

```{r unpivotr_324}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <- xlsx_cells(path, sheets = "pivot-centre-aligned")
rectify(all_cells)

all_cells <-
  xlsx_cells(path, sheets = "pivot-centre-aligned") %>%
  select(row, col, is_blank, data_type, character, numeric, local_format_id)

formats <- xlsx_formats(path)
top_borders <- which(!is.na(formats$local$border$top$style))
left_borders <- which(!is.na(formats$local$border$left$style))

first_header_row_corners <-
  dplyr::filter(all_cells, row == 2, local_format_id %in% left_borders) %>%
  select(row, col)
first_header_row_corners

first_header_col_corners <-
  dplyr::filter(all_cells, col == 2, local_format_id %in% top_borders) %>%
  select(row, col)
first_header_col_corners

first_header_row <-
  dplyr::filter(all_cells, !is_blank, row == 2) %>%
  select(row, col, sex = character)
  # the title of this header is 'sex'
  # the cells are text cells (`"Female"` and `"Male"`) so take the value in the
  # '`character` column.
first_header_row

first_header_col <-
  dplyr::filter(all_cells, !is_blank, col == 2) %>%
  select(row, col, field = character)
  # the title of this header is 'field', meaning 'group of subjects'.
  # The cells are text cells (`"Humanities"`, `"Performance"`) so take the value
  # in the '`character` column.
first_header_col

first_header_row <- justify(first_header_row, first_header_row_corners)
first_header_col <- justify(first_header_col, first_header_col_corners)

first_header_row
first_header_col

```

... dann weiter wie oben: [Zwei Zeilen- und Spaltenköpfe, links und oben ausgerichtet](#Zeilen_Spalten)


#### Mehrfache Zeilen- und Spaltenköpfe mit bedeutsamen Formatierungen

Vorgehen:

1. Zeilen- und Spaltenköpf entschlüsseln (*un-pivoting*), aber Variablen *row* und *col* jeder Zelle bewahren.
2. Formatierungen jeder Zelle einsammeln
3. Daten und Formatierungen zusammenführen

```{r unpivotr_325}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "pivot-annotations") %>%
  dplyr::filter(!is_blank) %>%
  select(row, col, data_type, character, numeric) %>%
  print()

rectify(all_cells)

first_header_row <-
  dplyr::filter(all_cells, row == 2) %>%
  select(row, col, sex = character)
  # the title of this header is 'sex'
  # the cells are text cells (`"Female"` and `"Male"`) so take the value in the
  # '`character` column.
first_header_row

second_header_row <-
  dplyr::filter(all_cells, row == 3) %>%
  select(row, col, name = character)
  # The title of this header is 'name'.
  # The cells are text cells, so take the value in the '`character` column.
second_header_row

first_header_col <-
  dplyr::filter(all_cells, col == 2) %>%
  select(row, col, field = character)
  # the title of this header is 'field', meaning 'group of subjects'.
  # The cells are text cells (`"Humanities"`, `"Performance"`) so take the value
  # in the '`character` column.
first_header_col

second_header_col <-
  dplyr::filter(all_cells, col == 3) %>%
  select(row, col, subject = character)
  # The title of this header is 'subject'
  # The cells are text cells (`"history"`, etc.) so take the value in the
  # '`character` column.
second_header_col

data_cells <-
  dplyr::filter(all_cells, data_type == "numeric") %>%
  select(row, col, score = numeric)
  # The data is exam scores in certain subjects, so give the data that title.
  # The data is numeric, so select only that 'value'.  If some of the data was
  # also text or true/false, then you would select the `character` and `logical`
  # columns as well as `numeric`

unpivoted <-
  data_cells %>%
  enhead(first_header_row, "up-left") %>%
  enhead(second_header_row, "up") %>%
  enhead(first_header_col, "left-up") %>%
  enhead(second_header_col, "left")
  # Don't delete the `row` and `col` columns yet, because we need them to join on
  # the formatting

# `formats` is a pallette of fill colours that can be indexed by the
# `local_format_id` of a given cell to get the fill colour of that cell
fill_colours <- xlsx_formats(path)$local$fill$patternFill$fgColor$rgb

# Import all the cells, filter out the header row, filter for the first column,
# and create a new column `approximate` based on the fill colours, by looking up
# the local_format_id of each cell in the `formats` pallette.
annotations <-
  xlsx_cells(path, sheets = "pivot-annotations") %>%
  dplyr::filter(row >= 4, col >= 4) %>% # Omit the headers
  mutate(fill_colour = fill_colours[local_format_id]) %>%
  select(row, col, fill_colour)
annotations

left_join(unpivoted, annotations, by = c("row", "col")) %>%
  select(-row, -col)

```


#### Köpfe und Anmerkungen gemischt, unterschieden durch Formatierung

Keine neuen Techniken. Trick: Beim Entschlüsseln der Zeilen- und Spaltenköpfe die "falschen" ausfiltern, die keine Köpfe darstellen.

S. nacnudus 3.2.6
https://nacnudus.github.io/spreadsheet-munging-strategies/pivot-complex.html#mixed-headers-and-notes-in-the-same-rowcolumn-distinguished-by-formatting-1


#### Gemische EBENEN von Köpfen in derselben Zeile / Spalte, unterschieden durch Formatierung

S. nacnudus 3.2.7
https://nacnudus.github.io/spreadsheet-munging-strategies/pivot-complex.html#mixed-levels-of-headers-in-the-same-rowcolumn-distinguished-by-formatting-1


#### Wiederholte Kopf-Zeilen / -Spalten innerhalb der Tabelle

Trick: Wiederholungen ignorieren

```{r unpivotr_328}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "pivot-repeated-headers") %>%
  dplyr::filter(!is_blank) %>%
  select(row, col, data_type, character, numeric) %>%
  print()

rectify(all_cells)

# The 'term' headers appear four times, but only the first one is needed.
term <-
  dplyr::filter(all_cells, row == 2) %>%
  select(row, col, term = character)
  # the title of this header is 'field', meaning 'group of subjects'.
  # The cells are text cells (`"Humanities"`, `"Performance"`) so take the value
  # in the '`character` column.
term

subject <-
  dplyr::filter(all_cells, col == 2) %>%
  select(row, col, subject = character)
  # The title of this header is 'subject'
  # The cells are text cells (`"history"`, etc.) so take the value in the
  # '`character` column.
subject

name <-
  dplyr::filter(all_cells, col == 3) %>%
  select(row, col, name = character)
  # The title of this header is 'name'.
  # The cells are text cells, so take the value in the '`character` column.
name

# The data cells are distinguished from the 'term' headers by their data type --
# the data cells are numeric, whereas the term headers are character.
data_cells <-
  dplyr::filter(all_cells, data_type == "numeric") %>%
  select(row, col, score = numeric)
  # The data is exam scores in certain subjects, so give the data that title.
  # The data is numeric, so select only that 'value'.  If some of the data was
  # also text or true/false, then you would select the `character` and `logical`
  # columns as well as `numeric`
data_cells

data_cells %>%
  enhead(term, "up") %>%
  enhead(subject, "up-left") %>%
  enhead(name, "left") %>%
  select(-row, -col)

```


#### Tabellenköpfe (Überschriften) innerhalb der Tabelle

Vorgehen: So tun als wären es Zeilen-Überschriften, mit "left-up"-Richtung arbeiten.

```{r unpivotr_329}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "pivot-header-within-data") %>%
  dplyr::filter(!is_blank) %>%
  select(row, col, data_type, character, numeric, local_format_id) %>%
  print()

rectify(all_cells)

bold <- which(xlsx_formats(path)$local$font$bold)

# The subject headers, though mixed with the data and the 'term' headers, are
# distinguishable by the data type "character" and by being bold.
subject <-
  dplyr::filter(all_cells,
         col == 3,
         data_type == "character",
         local_format_id %in% bold) %>%
  select(row, col, subject = character)
  # The title of this header is 'subject'
  # The cells are text cells (`"history"`, etc.) so take the value in the
  # '`character` column.
subject

# We only need one set of the 'term' headers
term <-
  dplyr::filter(all_cells, row == 3, data_type == "character") %>%
  select(row, col, term = character)
  # the title of this header is 'field', meaning 'group of subjects'.
  # The cells are text cells (`"Humanities"`, `"Performance"`) so take the value
  # in the '`character` column.
term

name <-
  dplyr::filter(all_cells, col == 2) %>%
  select(row, col, name = character)
  # The title of this header is 'name'.
  # The cells are text cells, so take the value in the '`character` column.
name

# The data cells are distinguished from the 'subject' headers by their data
# type -- the data cells are numeric, whereas the term headers are character.
data_cells <-
  dplyr::filter(all_cells, data_type == "numeric") %>%
  select(row, col, score = numeric)
  # The data is exam scores in certain subjects, so give the data that title.
  # The data is numeric, so select only that 'value'.  If some of the data was
  # also text or true/false, then you would select the `character` and `logical`
  # columns as well as `numeric`
data_cells

data_cells %>%
  enhead(subject, "left-up") %>%
  enhead(term, "up") %>%
  enhead(name, "left") %>%
  select(-row, -col)


```

## "Small multiples": Kleine, vervielfältigte Tabellen

Üblicher bei Grafiken (ggplot2 facets), auch auf Arbeitsblättern anzutreffen.

Vorgehen:
1. Code für den Import einer Tabelle
2. Code in Funktion packen
3. Arbeitsblatt so aufteilen, dass jede Tabelle auf einem Abschnitt liegt
4. Die Funktion auf die Abschnitte anwenden


### Jede Tabelle enthält alle Tabellenköpfe

```{r unpivotr_41}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "small-multiples") %>%
  dplyr::filter(!is_blank) %>%
  select(row, col, data_type, character, numeric, local_format_id)

table1 <- dplyr::filter(all_cells, row %in% 1:4, col %in% 1:3)

rectify(table1)

table1 %>%
  behead("up-left", subject) %>%
  behead("up", header) %>%
  select(-col, -local_format_id) %>%
  spatter(header) %>%
  select(-row)

# Code in Funktion packen

unpivot <- function(cells) {
  cells %>%
    behead("up-left", subject) %>%
    behead("up", header) %>%
    select(-col, -local_format_id) %>%
    spatter(header) %>%
    select(-row)
}

formats <- xlsx_formats(path)
str(formats, max.level = 2)

italic <- which(formats$local$font$italic)

corners <-
  all_cells %>%
  dplyr::filter(local_format_id %in% italic) %>%
  select(row, col)

partitions <- partition(all_cells, corners)
partitions

partitions %>%
  mutate(cells = map(cells, unpivot)) %>%
  unnest() %>%
  select(-corner_row, -corner_col)

```

From ?partition:
Given the positions of corner cells that mark individual tables in a single spreadsheet, *partition()* works out which table cells belong to which corner cells. The individual tables can then be worked on independently.

*partition()* partitions along both dimensions (rows and columns) at once. *partition_dim()* partitions along one dimension at a time.


### Gleiche Tabelle auf mehreren Blättern / in mehreren Dateien

*xlsx_cells()* kann mehrere Blätter gleichzeitig verarbeiten. Namen angeben; wenn keine Namen: alle Blätter werden importiert.

*tidyxl* verarbeitet das Blatt (*sheet*) als weitere Koordinate neben *row* und *col*.

```{r unpivotr_42}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = c("humanities", "performance")) %>%
  dplyr::filter(!is_blank) %>%
  select(sheet, row, col, data_type, character, numeric)
all_cells

# tidyr::nest()

all_cells %>%
  nest(-sheet)

unpivot <- function(cells) {
  cells %>%
    behead("up", name) %>%
    behead("left", subject)
}

all_cells %>%
  nest(-sheet) %>%
  mutate(data = map(data, unpivot)) %>%
  unnest()

all_cells %>%
  nest(-sheet) %>%
  mutate(data = map(data, unpivot)) %>%
  unnest() %>%
  transmute(field = sheet,
            name,
            subject,
            score = numeric)

```


### Gleiche Tabelle auf mehreren Blättern, aber in unterschiedlichen Positionen

Funktion für *unpivot* muss die Tabelle zuerst finden.

```{r unpivotr_43}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = c("female", "male")) %>%
  dplyr::filter(!is_blank) %>%
  select(sheet, row, col, data_type, character, numeric)
all_cells

unpivot <- function(cells) {
  cells %>%
    dplyr::filter(character == "Subject") %>%
    pull(row) %>%
    {dplyr::filter(cells, row >= .)} %>%
    behead("up", name) %>%
    behead("left", subject)
}

all_cells %>%
  nest(-sheet) %>%
  mutate(data = map(data, unpivot)) %>%
  unnest() %>%
  select(sex = sheet, name, subject, score = numeric)


```


### Implizite Vielfache

* Sehen aus wie einzelne Tabelle
* Kopf-Infos erscheinen mehrfach

Im Beispiel: "Grade" wird wiederholt

* Gehört zum jeweiligen übergeordneten Kopf "Classics", "History", "Music", "Drama"
* Doppelte Funktion: Titel der Einzeltabelle (*small multiple*) sowie als "Punktzahl" (*score*) der jeweiligen Spalte
* --> Herausforderung: "Grade" auf die richtige Punktzahl beziehen

Vorgehen:
1. Nach "Classics", "History", "Music", "Drama" filtern
2. Diese einer Variable zuordnen, auf die später *enhead()* angewendet wird
3. *behead()* der originalen "Classics", "History" etc. Zellen und diese mit "Score" überschreiben

```{r unpivotr_44}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
all_cells <-
  xlsx_cells(path, sheets = "implied-multiples") %>%
  dplyr::filter(!is_blank) %>%
  select(row, col, data_type, character, numeric)

subjects <-
  all_cells %>%
  dplyr::filter(col >= 2, row == 2, character != "Grade") %>%
  select(row, col, subject = character)
subjects

all_cells %>%
  behead("up-left", "field") %>%
  behead("up", "header") %>%
  behead("left", "name") %>%
  enhead(subjects, "up-left") %>% # Reattach the filtered subject headers
  mutate(header = if_else(header == "Grade", header, "Score")) %>%
  select(-col) %>%
  spatter(header) %>%
  select(-row)

```

## Formatierungen

Bis hier wurden bereits Formatierungen verwendet; hier Detail-Erklärungen. Motivation: Umgang mit hochgestellten Symbolen.

* Vektor mit den Formaten extrahieren
* *style_format* oder *local_format_id* einer Zelle nachschlagen

```{r unpivotr_51a}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
cells <-
  xlsx_cells(path, sheet = "formatting") %>%
  select(row, col, character, style_format, local_format_id)
cells

# Ist eine Zelle fett?

formats <- xlsx_formats(path)
bold <- formats$local$font$bold # The list of lists of lists of vectors
bold

mutate(cells, bold = bold[local_format_id])

```

Warum ist die Liste aus *xlsx_formats()* so kompiziert? Viele Formatierungsoptionen. Beispiel Rahmen (*borders*): 40 Variablen ... Excel vergibt stattdessen IDs für Kombinationen von Formatierungen. Jede Zelle wird mit **einer** solchen ID beschrieben. ==> Zwei Zellen mit Fettschrift können unterschiedliche IDs haben, wenn die zweite z. B. auch kursiv gesetzt ist.

Hierarchie der Formatierungen:

1. Stil: *xlsx_formats()$style*. Damit kann man **alle** als normal formatierten Zellen *auf ein Mal* ändern.
2. Lokal: *xlsx_formats()$local*. Bezieht sich auf eine einzelne Zelle. Gleiche Struktur wie *style*.


### Formatierungen einer Zelle ermitteln

```{r unpivotr_51b}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
cells <-
  xlsx_cells(path, sheet = "formatting") %>%
  select(row, col, character, style_format, local_format_id) %>%
  dplyr::filter(row == 1, col == 1)
cells

formats <- xlsx_formats(path)

local_bold <- formats$local$font$bold
local_bold

style_bold <- formats$style$font$bold
style_bold

mutate(cells,
       style_bold = style_bold[style_format],
       local_bold = local_bold[local_format_id])

```

Meist arbeitet man eher mit der lokalen Formatierung. *styles* nur relevant, wenn Stile für ein gesamtes Blatt genutzt werden (selten) und man lokale Modifikationen des Stils ignorieren möchte.

Bedingte Formatierungen wurden absichtlich weggelassen. Sie *reagieren* nur auf Zellenwerte und enthalten daher keine *neuen* Informationen.


### Übliche Formatierungen

```{r unpivotr_52}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
cells <-
  xlsx_cells(path, sheet = "formatting") %>%
  select(row, col, character, style_format, local_format_id, height, width)

formats <- xlsx_formats(path)

bold <- formats$local$font$bold
italic <- formats$local$font$italic
underline <- formats$local$font$underline
strikethrough <- formats$local$font$strike
font_colour <- formats$local$font$color$rgb
fill_colour <- formats$local$fill$patternFill$fgColor$rgb
font_size <- formats$local$font$size
font_name <- formats$local$font$name
border_colour <- formats$local$border$right$color$rgb
border_linetype <- formats$local$border$right$style

mutate(cells,
       bold = bold[local_format_id],
       italic = italic[local_format_id],
       underline = underline[local_format_id],
       strikethrough = strikethrough[local_format_id],
       font_colour = font_colour[local_format_id],
       font_size = font_size[local_format_id],
       font_name = font_name[local_format_id],
       fill_colour = fill_colour[local_format_id],
       border_colour = border_colour[local_format_id],
       border_linetype = border_linetype[local_format_id])

```


### Mehrere Formatierungen innerhalb einer Zelle

Voriger Abschnitt: Formatierungen auf Zell-Ebene   
Hier: *Mehrere* Formatierungen innerhalb einer Zelle

Möglichkeiten sind deutlich stärker begrenzt --> Datensatz mit vorgegebenen Spalten

Ein Datensatz **pro Zelle**, diese werden in einer "Listen-Variable" *character_formatted* gespeichert.

```{r}

path <- system.file("extdata", "worked-examples.xlsx", package = "unpivotr")
xlsx_cells(path, sheet = "in-cell formatting") %>%
  select(address, character_formatted)

# Zugriff über tidyr::unnest()

xlsx_cells(path, sheet = "in-cell formatting") %>%
  dplyr::filter(address == "A1") %>%
  select(address, character_formatted) %>%
  unnest()

```


# Datums- und Zeitfelder



# Sich einen Datensatz erschließen: Explorative Datenanalyse

* skimr
* DataExplorer
* GGAlly


# Daten aus mehreren Quellen zusammenfügen

* dplyr, two table verbs: join-Familie


# Arbeiten mit Texten (Strings und Factors)

* Beispiel für fct_lump_*, z. B. Autozulassungen
* Textanalyse-Beispiel


# Umgang mit Fehlwerten

* Einige Base R-Funktionen
* naniar
* simputation
* Evtl. Imputation mit caret?

